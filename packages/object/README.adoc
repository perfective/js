= Object

The `@perfective/object` package provides functions to work with the standard JS
`link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object[Object]` class.

* Types:
** `ObjectWithDefined<T, K extends keyof T>`
** `ObjectWithUndefined<T, K extends keyof T>`
** `ObjectWithNotNull<T, K extends keyof T>`
** `ObjectWithNull<T, K extends keyof T>`
** `ObjectWithPresent<T, K extends keyof T>`
** `ObjectWithAbsent<T, K extends keyof T>`
** `RecursivePartial<T>`
** `Entry<T = unknown>`
+
* Unit functions:
** `copy<T>(value: T): T`
— creates a shallow copy of the given value. (Experimental).
** `clone<T>(value: T): T`
— creates a clone (deep copy) of the given value. (Experimental).
** `pick<T, K extends keyof T>(record: T, ...property: readonly K[]): Pick<T, K>`
— creates a copy of the `record` only with the given `property`.
** `omit<T, K extends keyof T>(record: T, ...property: readonly K[]): Omit<T, K>`
— creates a copy of the `record` without the given `property`.
** `filter<T, K extends keyof T>(record: T, condition: Predicate<T[K]>): Partial<T>`
— creates a copy of the `record` where each value meets the `condition`.
** `assign<T, V = Partial<T>>(value: T, ...overrides: (V | Partial<T>)[]): T & V`
— creates a shallow copy of the given value with the given overrides.
** `recordFromArray(array: string[]): Record<string, number>`
** `recordFromEntries(entries: Entry[]): Record<string, unknown>`
** `recordWithPicked<T, K extends keyof T>(...property: readonly K[]): Unary<T, Pick<T, K>>`
— partially applies the `pick()` function for the given `property`.
** `recordWithOmitted<T, K extends keyof T>(...property: readonly K[]): Unary<T, Omit<T, K>>`
— partially applies the `omit()` function for the given `property`.
** `recordFiltered<T, K extends keyof T = keyof T>(condition: Predicate<T[K]>): Unary<T, Partial<T>>`
— partially applies the `filter()` function for the given `condition`.
+
* Type guards:
** `hasDefinedProperty<T, K extends keyof T>(property: K, ...and: readonly K[]): (value: T) => value is ObjectWithDefined<T, K>`
** `hasUndefinedProperty<T, K extends keyof T>(property: K, ...and: readonly K[]): (value: T) => value is ObjectWithUndefined<T, K>`
** `hasNotNullProperty<T, K extends keyof T>(property: K, ...and: readonly K[]): (value: T) => value is ObjectWithNotNull<T, K>`
** `hasNullProperty<T, K extends keyof T>(property: K, ...and: readonly K[]): (value: T) => value is ObjectWithNull<T, K>`
** `hasPresentProperty<T, K extends keyof T>(property: K, ...and: readonly K[]): (value: T) => value is ObjectWithPresent<T, K>`
** `hasAbsentProperty<T, K extends keyof T>(property: K, ...and: readonly K[]): (value: T) => value is ObjectWithAbsent<T, K>`
+
* Predicates:
** `isObject<T>(value: T | null): boolean`
** `isRecord<T>(value: T): boolean`
— returns `true` when the value is an object created from the `Object` class (not an `Array`, `Date`, etc.).
** `isTruthy<T>(value: T): boolean`
** `isFalsy<T>(value: T): boolean`
** `isEmpty<T>(value: T): boolean`
— returns `true` when the value is truthy or is a non-empty array or object.
+
* Reducers:
** `toRecordFromEntries(record: Record<string, unknown>, value: Entry): Record<string, unknown>`
+
* Property functions:
** `property<T, K extends keyof T>(property: K): Unary<T, T[K]>`
** `property<T, K extends keyof T>(property: K, condition: Predicate<T[K]>): Predicate<T>`
** `by<T, K extends keyof T>(property: K, ordering: Compare<T[K]>): Compare<T>`
